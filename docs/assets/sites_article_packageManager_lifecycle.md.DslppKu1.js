import{_ as i,c as a,o as e,al as n,aH as l}from"./chunks/framework.CQoeh1S1.js";const g=JSON.parse('{"title":"패키지 매니저는 어떻게 동작할까?","description":"패키지 매니저의 Resolution, Fetch, Link의 역할을 설명한다.","frontmatter":{"title":"패키지 매니저는 어떻게 동작할까?","description":"패키지 매니저의 Resolution, Fetch, Link의 역할을 설명한다.","outline":"deep","head":[["link",{"rel":"canonical","href":"https://mslee98.github.io/sites/article/packageManager/lifecycle"}]]},"headers":[],"relativePath":"sites/article/packageManager/lifecycle.md","filePath":"sites/article/packageManager/lifecycle.md"}'),t={name:"sites/article/packageManager/lifecycle.md"};function p(h,s,k,r,o,d){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="패키지-매니저-동작-과정" tabindex="-1">패키지 매니저 동작 과정 <a class="header-anchor" href="#패키지-매니저-동작-과정" aria-label="Permalink to “패키지 매니저 동작 과정”">​</a></h1><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  mslee98@MacBookPro</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yarn</span></span></code></pre></div><p>위와 같은 명령어를 입력하면 아래와 같은 결과가 나타난다.</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ·</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Yarn</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4.5.2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ┌</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Resolution</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> step</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 1단계</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> └</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Completed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ┌</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Post-resolution</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> validation</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> └</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Completed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ┌</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Fetch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> step</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 2단계</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> └</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Completed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ┌</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Link</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> step</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 3단계</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> └</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Completed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➤</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> YN0000:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ·</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Done</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> with</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> warnings</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 0s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 142ms</span></span></code></pre></div><p>그렇다 <strong>패키지 매니저</strong>는 크게 <code>Resolution</code>, <code>Fetch</code>, <code>Link</code> 3단계를 거친다.</p><h2 id="resolution-단계" tabindex="-1">Resolution 단계 <a class="header-anchor" href="#resolution-단계" aria-label="Permalink to “Resolution 단계”">​</a></h2><div class="info custom-block"><p class="custom-block-title">Resolution 단계 요약</p><ul><li>라이브러리 버전 고정</li><li>라이브러리의 다른 의존성 확인</li><li>라이브러리의 다른 의존성 버전 고정</li></ul></div><p><code>package.json</code>을 보면 의존성이 아래처럼 명시되어있다.</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^18.2.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p><code>react</code> 이라고 명시되어 있으면 <strong><code>^</code></strong>이 나타내는 규칙에 따라 <code>≥ 18.2.0, &lt; 19</code> 사이의 버전을 사용하며, 패키지 매니저는 저 범위 내에서 가장 최신 버전을 사용하려고 한다.</p><p><strong>즉, 라이브러리 버전을 고정한다.</strong></p><h2 id="fetch-단계" tabindex="-1">Fetch 단계 <a class="header-anchor" href="#fetch-단계" aria-label="Permalink to “Fetch 단계”">​</a></h2><div class="info custom-block"><p class="custom-block-title">Fetch 단계 요약</p><ul><li>결정된 버전의 파일을 다운로드 하는 과정</li></ul></div><p>이 부분에서는 Resolution의 결과로 결정된 버전을 실제로 다운로드 하는 과정이다</p><p>(일반적으로 99%는 <code>npm</code>레지스트리에서 받아온다)</p><h2 id="link-단계" tabindex="-1">Link 단계 <a class="header-anchor" href="#link-단계" aria-label="Permalink to “Link 단계”">​</a></h2><div class="info custom-block"><p class="custom-block-title">Link 단계 요약</p><ul><li>Resolution/Fetch 된 라이브러리를 소스 코드에서 사용할 수 있는 환경을 제공하는 과정</li></ul></div><p><code>package.json</code>에서 명시하는 모든 의존성을 <code>node_modules</code> 디렉토리 밑에다가 하나하나씩 쓰는게 <code>npm Linker</code>의 역할</p><blockquote><ul><li>npm / yarn(classic) - node_modules 기반 Link</li><li>Yarn Berry는 node_mdules없이 PnP로 처리한다.</li></ul></blockquote><p>각 패키지 매니저의 방식을 살펴보고 자세하게 기술해보겠음</p><blockquote><ul><li>npm Linker</li><li>pnpm Linker</li><li>PnP Linker</li></ul></blockquote><h3 id="_1-npm-linker" tabindex="-1">1. npm Linker <a class="header-anchor" href="#_1-npm-linker" aria-label="Permalink to “1. npm Linker”">​</a></h3><p>npm Linker는 의존성 그래프를 폴더 중첩 구조로 물리적으로 표현한다. 즉, 의존성 관계를 그대로 node_modules 폴더 구조로 만든다.</p><p>왜 이런 구조가 필요할까?</p><h4 id="npm-linker-구조-feat-순회참조" tabindex="-1">npm Linker 구조(feat. 순회참조) <a class="header-anchor" href="#npm-linker-구조-feat-순회참조" aria-label="Permalink to “npm Linker 구조(feat. 순회참조)”">​</a></h4><p><code>import React from &#39;react&#39;</code>구문을 만난다면 현재 파일 위치 기준으로 ./node_modules/react 없다면 ../node_modules/react 루트까지 반복한다.</p><p>그렇기에 node_modules를 타고 올라가는 구조가 필요하며, 의존성마다 자기 node_modules를 가질 수 있게 만든다.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>my-service/</span></span>
<span class="line"><span>└─ \`node_modules/\`</span></span>
<span class="line"><span>|  ├─ react/</span></span>
<span class="line"><span>|  |  </span></span>
<span class="line"><span>|  └─ @tossteam/tds-mobile/</span></span>
<span class="line"><span>|     └─ \`node_modules/\`</span></span>
<span class="line"><span>|         └─ @radix-ui/react-dialog</span></span>
<span class="line"><span>|</span></span>
<span class="line"><span>└─ src</span></span>
<span class="line"><span>    └─ index.ts</span></span></code></pre></div><p>하지만 위 방식의 근본적인 문제가 있는데 바로 <strong>중복</strong>이다</p><ul><li>버전이 같아도 트리가 다르면 물리적으로 복사된다.</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>lib-a/node_modules/react</span></span>
<span class="line"><span>lib-b/node_modules/react</span></span>
<span class="line"><span>lib-c/node_modules/react</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>npm 에서는 이 문제를 해결하기 위해 Hostring 기법을 사용하는데</p><h4 id="hoisting-유령-의존성" tabindex="-1">Hoisting(유령 의존성) <a class="header-anchor" href="#hoisting-유령-의존성" aria-label="Permalink to “Hoisting(유령 의존성)”">​</a></h4><p>npm Linker는 구조상 같은 패키지가 여러 의존성 트리에 있으면 여러 번 복사될 수 있고, 이 중복을 줄이기 위해 호이스팅을 사용한다.</p><p>공통으로 사용되는 라이브러리를 최상단으로 올리는 방식</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>node_modules/</span></span>
<span class="line"><span>└─ react   ← 하나만 둠</span></span></code></pre></div><figure><img src="`+l+'" alt="Alternative text for image"><figcaption> 출처: <a href="https://toss.tech/article/node-modules-and-yarn-berry" target="_blank">[node_modules로부터-우리를-구원해-줄-Yarn-Berry]</a></figcaption></figure><p>왼쪽 트리에서는 <code>[A (1.0)]</code>과 <code>[B (1.0)]</code> 패키지는 두 번 설치되므로 디스크 공간을 낭비한다. <code>npm</code>과 <code>Yarn Classic(v1)</code>에서는 디스크 공간을 아끼기 위해 Hoisting을 하여 오른쪽 트리로 바꾼다.</p><p>호이스팅 된 <code>package-1</code>에서는 기존에 바로 <code>require()</code>할 수 없던 <code>[B (1.0)]</code>을 라이브러리로 불러올 수 있게 되는데 <em><strong>직접적으로 의존하고 있지 않은 라이브러리를 <code>require()</code> 할 수 있는 현상을 유령 의존성이라 한다.</strong></em></p><hr><h4 id="정리" tabindex="-1">정리 <a class="header-anchor" href="#정리" aria-label="Permalink to “정리”">​</a></h4><p>하지만 임시방편일 뿐 문제가 많다.</p><blockquote><p><strong>첫 번째로</strong>는 위에서 언급한 <em><strong>순회참조</strong></em></p><ul><li><code>import</code> 현재 경로로 부터 최상단 루트까지 <code>node_modules</code>를 탐색하는 순회 참조 문제. <br><br></li></ul><p><strong>두 번쨰로</strong> 구조적인 부분에서</p><ul><li>버전이 다른경우 X</li><li>perrDependency가 있다면 X (사용하지는 않지만 호환성을 위해 필요한 의존성)</li><li>의존성 구조가 조금만 바뀌어도 X <br><br></li></ul><p><strong>세 번쨰로</strong> 위에서 언급한 <em><strong>유령 의존성(Phantom Dependency)</strong></em></p><ul><li>직접적으로 <code>require()</code> 할 수 없던 의존성을 직접적으로 의존하게 되는 문제</li></ul></blockquote><p><br><br></p><p><code>node_modules</code> 구조 자체가 큰 문제가 있는데 <code>pnpm</code>과 <code>Yarn Berry(v2+)</code>는 어떻게 해결한걸까</p><ul><li><code>pnpm</code> &gt; <code>node_modules</code> 그래도 사용하나, <em><strong>Hard Link</strong></em>방식으로 해결 <ul><li>자세한건 <a href="#_2-pnpm-linker">2.pnpm Linker</a> 참조</li></ul></li><li><code>Yarn Berry</code> &gt; <code>PnP</code> 방식으로 <code>node_modules</code>를 대체 <ul><li>자세한건 <a href="#_3-pnp-linker">3.PnP Linker</a> 참조</li></ul></li></ul><hr><h3 id="_2-pnpm-linker" tabindex="-1">2. pnpm Linker <a class="header-anchor" href="#_2-pnpm-linker" aria-label="Permalink to “2. pnpm Linker”">​</a></h3><hr><h3 id="_3-pnp-linker" tabindex="-1">3. PnP Linker <a class="header-anchor" href="#_3-pnp-linker" aria-label="Permalink to “3. PnP Linker”">​</a></h3>',50)])])}const F=i(t,[["render",p]]);export{g as __pageData,F as default};
