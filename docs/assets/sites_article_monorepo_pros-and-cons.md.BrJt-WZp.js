import{_ as e,c as i,o as r,al as a}from"./chunks/framework.CQoeh1S1.js";const b=JSON.parse('{"title":"Monorepo vs Multirepo | 장단점과 선택 기준","description":"프론트엔드 관점에서 모노레포와 멀티레포의 장단점을 비교하고, 팀 규모와 프로젝트 성격에 따른 선택 기준을 정리합니다.","frontmatter":{"title":"Monorepo vs Multirepo | 장단점과 선택 기준","description":"프론트엔드 관점에서 모노레포와 멀티레포의 장단점을 비교하고, 팀 규모와 프로젝트 성격에 따른 선택 기준을 정리합니다.","outline":"deep","head":[["link",{"rel":"canonical","href":"https://mslee98.github.io/sites/article/monorepo/pros-and-cons"}]]},"headers":[],"relativePath":"sites/article/monorepo/pros-and-cons.md","filePath":"sites/article/monorepo/pros-and-cons.md"}'),l={name:"sites/article/monorepo/pros-and-cons.md"};function t(s,o,n,p,h,d){return r(),i("div",null,[...o[0]||(o[0]=[a('<h1 id="monorepo-vs-multirepo-장단점" tabindex="-1">Monorepo vs Multirepo 장단점 <a class="header-anchor" href="#monorepo-vs-multirepo-장단점" aria-label="Permalink to “Monorepo vs Multirepo 장단점”">​</a></h1><h2 id="monorepo" tabindex="-1">Monorepo <a class="header-anchor" href="#monorepo" aria-label="Permalink to “Monorepo”">​</a></h2><h3 id="✅-monorepo-장점" tabindex="-1">✅ Monorepo 장점 <a class="header-anchor" href="#✅-monorepo-장점" aria-label="Permalink to “✅ Monorepo 장점”">​</a></h3><h4 id="_1-의존성-관리가-쉽다" tabindex="-1">1. 의존성 관리가 쉽다 <a class="header-anchor" href="#_1-의존성-관리가-쉽다" aria-label="Permalink to “1. 의존성 관리가 쉽다”">​</a></h4><p>모든 프로젝트가<br><strong>하나의 의존성 그래프를 공유</strong>한다.</p><ul><li>동일 라이브러리 중복 설치 방지</li><li>버전 불일치로 인한 이슈 감소</li><li><code>Yarn Workspace</code> / <code>pnpm workspace</code> 캐시 공유</li></ul><p>프론트 프로젝트를 여러번 운영해본 사람이라면<br> 의존성 버전 문제로 고생한 경험이 한 번쯤은 있을 것이다.</p><hr><h4 id="_2-공통-컴포넌트-디자인-시스템-관리가-편하다" tabindex="-1">2. 공통 컴포넌트(디자인 시스템) 관리가 편하다 <a class="header-anchor" href="#_2-공통-컴포넌트-디자인-시스템-관리가-편하다" aria-label="Permalink to “2. 공통 컴포넌트(디자인 시스템) 관리가 편하다”">​</a></h4><p>멀티레포 환경에서도 공통 코드를 사용할 수는 있다.</p><p>하지만 대부분의 경우 아래 과정을 거친다.</p><ul><li>공통 패키지 분리</li><li>npm 배포</li><li>버전 관리</li><li>각 서비스에서 다시 설치</li></ul><p>이 과정 자체가 문제는 아니지만, <code>Storybook</code> 기반의 디자인 시스템을 운영하는 상황이라면 이야기가 조금 달라진다.</p><p>각 서비스에서 스타일이나 컴포넌트를 조금씩 개별 수정하기 시작하면, 어느 순간 디자인 시스템과 실제 서비스 UI가 어긋나기 시작하고 결국 “이게 최신이 맞나?” 하는 동기화 문제를 다시 겪게 된다.</p><p>반면 모노레포에서는<br> 공통 코드를 패키지로 분리한 뒤<br><strong>ESM 방식으로 바로 import</strong>할 수 있다.</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Button } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@shared/ui&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ul><li>배포 필요 없음</li><li><strong>수정 사항들이 즉시 반영!</strong></li><li>UI / 유틸 / 타입 공유가 매우 수월</li></ul><p>👉 아무래도 <strong>Monorepo</strong>가 많이 발전하면서 <strong>디자인 시스템</strong>도 같이 발전하는거 아닐까?</p><div class="info custom-block"><p class="custom-block-title">다만 개인적인 생각으로는,</p><p>디자인 시스템은 결국 라이브러리 형태로 가져가는 게 더 잘 맞는 방향이라고 생각한다.</p><p>토스의 <strong>Deus</strong>처럼 전용 툴을 사용하는 경우가 아니라면, <strong>Chromatic</strong> + <strong>Zeplin</strong> + <strong>Figma</strong> + <strong>Storybook</strong> 조합만으로도 기획자, 디자이너, 퍼블리셔 간 협업이 꽤 자연스럽게 흘러간다. 실제로 UI 오차도 눈에 띄게 줄어드는 편이다.</p><p>여기에 더해</p><ul><li>크로스 브라우저 체크</li><li>접근성 및 UI 테스트</li><li>Git 브랜치 단위로 변경 사항을 시각적으로 확인하는 과정</li></ul><p>같은 작업들도 비교적 수월하게 진행할 수 있다.</p><p>이런 흐름을 고려해보면, 디자인 시스템을 서비스 레포지토리에 무리해서 포함시키기보다는 아예 별도의 라이브러리로 분리해 배포하는 방식이 더 낫지 않을까라는 생각이 들었다.</p></div><hr><h4 id="_3-개발-생산성과-편의성" tabindex="-1">3. 개발 생산성과 편의성 <a class="header-anchor" href="#_3-개발-생산성과-편의성" aria-label="Permalink to “3. 개발 생산성과 편의성”">​</a></h4><p>다음과 같은 설정들을<br> 각 프로젝트마다 반복할 필요가 없다.</p><ul><li><code>eslint</code></li><li><code>prettier</code></li><li><code>TypeScript</code> 설정</li><li><code>tsconfig path</code></li><li>공통 스크립트</li></ul><p>👉 <strong>Root 레벨에서 한 번에 관리 가능</strong></p><p>개발 환경을 맞추는 데 드는 비용이<br> 확실히 줄어든다.</p><hr><h3 id="⚠️-monorepo-단점" tabindex="-1">⚠️ Monorepo 단점 <a class="header-anchor" href="#⚠️-monorepo-단점" aria-label="Permalink to “⚠️ Monorepo 단점”">​</a></h3><h4 id="_1-초기-설정-비용이-크다" tabindex="-1">1. 초기 설정 비용이 크다 <a class="header-anchor" href="#_1-초기-설정-비용이-크다" aria-label="Permalink to “1. 초기 설정 비용이 크다”">​</a></h4><ul><li>Workspace 구조 설계</li><li>패키지 간 의존성 설계</li><li>빌드 / 테스트 범위 분리</li></ul><p>아무 생각 없이 시작하면 중간중간 다시 손봐야 할 부분이 계속 생긴다.</p><blockquote><p>모노레포는 &quot;일단 만들어두고 쓰는 구조&quot;가 아니다. 병렬적으로 CI를 처리한다든가 CI/CD 수준에서도 고민을 많이 해봐야한다.</p></blockquote><hr><h4 id="_2-저장소가-비대해진다" tabindex="-1">2. 저장소가 비대해진다 <a class="header-anchor" href="#_2-저장소가-비대해진다" aria-label="Permalink to “2. 저장소가 비대해진다”">​</a></h4><p>여러 프로젝트가<br> 하나의 Repository에 모이다 보니<br> 저장소 크기가 커질 수밖에 없다.</p><ul><li>clone 시간 증가</li><li>IDE 인덱싱 부담</li><li>대규모 조직에서는 성능 이슈 발생 가능</li></ul><h2 id="multirepo" tabindex="-1">Multirepo <a class="header-anchor" href="#multirepo" aria-label="Permalink to “Multirepo”">​</a></h2><h3 id="✅-multirepo-장점" tabindex="-1">✅ Multirepo 장점 <a class="header-anchor" href="#✅-multirepo-장점" aria-label="Permalink to “✅ Multirepo 장점”">​</a></h3><h4 id="_1-구조가-단순하다" tabindex="-1">1. 구조가 단순하다 <a class="header-anchor" href="#_1-구조가-단순하다" aria-label="Permalink to “1. 구조가 단순하다”">​</a></h4><ul><li>하나의 서비스 = 하나의 Repository</li><li>이해하기 쉽고 진입 장벽이 낮다</li></ul><p>소규모 팀이나<br> 단일 서비스에는 여전히 강력한 선택지다.</p><hr><h4 id="_2-서비스-간-완전한-독립성" tabindex="-1">2. 서비스 간 완전한 독립성 <a class="header-anchor" href="#_2-서비스-간-완전한-독립성" aria-label="Permalink to “2. 서비스 간 완전한 독립성”">​</a></h4><ul><li>배포 주기 분리</li><li>의존성 완전 분리</li><li>장애 전파 최소화</li></ul><p>한 서비스의 문제가<br> 다른 서비스에 영향을 주지 않는다.</p><hr><h3 id="⚠️-multirepo-단점" tabindex="-1">⚠️ Multirepo 단점 <a class="header-anchor" href="#⚠️-multirepo-단점" aria-label="Permalink to “⚠️ Multirepo 단점”">​</a></h3><h4 id="_1-공통-코드-관리가-어렵다" tabindex="-1">1. 공통 코드 관리가 어렵다 <a class="header-anchor" href="#_1-공통-코드-관리가-어렵다" aria-label="Permalink to “1. 공통 코드 관리가 어렵다”">​</a></h4><p>공통 코드 변경 시<br> 다음 과정을 반복하게 된다.</p><ul><li>라이브러리 수정</li><li>버전 업데이트</li><li>npm 배포</li><li>각 서비스에서 다시 설치</li></ul><p>이 과정이 반복되다 보면<br> 결국 <strong>복붙과 파편화</strong>로 이어지기 쉽다.</p><hr><h4 id="_2-의존성-버전-관리가-까다롭다" tabindex="-1">2. 의존성 버전 관리가 까다롭다 <a class="header-anchor" href="#_2-의존성-버전-관리가-까다롭다" aria-label="Permalink to “2. 의존성 버전 관리가 까다롭다”">​</a></h4><p>각 Repository가<br> 독립적으로 의존성을 관리하다 보니<br> 같은 라이브러리를<br> 서로 다른 버전으로 사용하는 일이 잦다.</p><h2 id="마무리" tabindex="-1">마무리 <a class="header-anchor" href="#마무리" aria-label="Permalink to “마무리”">​</a></h2><p>Monorepo와 Multirepo는<br> 서로 우열을 가리는 관계가 아니다.</p><blockquote><p><strong>Monorepo는 관리 효율을 선택하는 것이고</strong><br><strong>Multirepo는 독립성을 선택하는 것이다.</strong></p></blockquote><p>프로젝트 규모와 팀 구조를 고려해<br> 가장 잘 맞는 방식을 선택하는 것이 중요하다.</p><p>나처럼<br> &quot;플랫폼 팀은 없지만, 구조는 갖추고 싶다&quot;면<br> 혼자서라도 모노레포를 경험해보는 건<br> 충분히 의미가 있다고 생각한다.</p>',58)])])}const u=e(l,[["render",t]]);export{b as __pageData,u as default};
